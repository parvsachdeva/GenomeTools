#!/usr/bin/perl
#########################################################################################################################################
#This program takes input of a string and kmer length from a user and prints all the unique kmers and then finds all possible shortest common superstrings based on orders generated by a permutation function which uses the number of unique kmers.
#To compile on a Linux platform : "perl kmer.pl" or after providing executable permission : "./scs.pl"
#########################################################################################################################################
sub allcomb{
my @arr=@{$_[0]};
my $first=$_[1];
my $last=$_[2];
if($first==$last){
$tcnt++;
foreach $x(@arr){
$perm[$tcnt-1].=$x;}
}else{
	for(my $i=$first;$i<=$last;$i++){
	my $tmp=$arr[$first];
	$arr[$first]=$arr[$i];
	$arr[$i]=$tmp;
	allcomb(\@arr,($first+1),$last);
	$tmp=$arr[$first];
	$arr[$first]=$arr[$i];
	$arr[$i]=$tmp;
	}
}
}
#########################################################################################################################################
sub overlap{
my $st1=$_[0];
my $st2=$_[1];my $str="";my $chkx=0;my $len1=length $st2;
for(my $i=0;$i<length $st1;$i++){
my $chkx=0;$chnum=1;
my $tmp=$st2;
	for(my $j=0;$j<$len1;$j++){
		
		if(substr($st1, $i) eq $tmp){
		#print substr($st1, $i);
		#print "...";print substr $st2,($len1-$j);print "..$tmp\n";
		
		return (substr $st2,($len1-$j));
		break;
		}else{
		chop $tmp;
		
		}		
	}
}
if($chkx==0){
return $st2;
}
}
#########################################################################################################################################
print "Enter a string : ";			#Input of string
$str1=<>;
chomp $str1;
$klen=length($str1)+10;
while($klen>length($str1)){
print "Enter length of kmer : ";		#Input of kmer length
$klen=<>;
if($klen>length($str1)){
print "Length of kmer cannot exceed length of string!\n";
}
}
chomp $klen;
$len=length($str1);				#Calculating string length
@str2=split('',$str1);
$i=0;
print"String : $str1\nLength of string : $len\nLength of kmers : $klen\n";
#########################################################################################################################################
for($i=0;$i<$len-$klen+1;$i++){
$k=$i+1;
	for($j=0;$j<$klen;$j++){
	$kmer[$i].="$str2[$i+$j]";
	}
#print "kmer $k : $kmer[$i]\n";			#Printing all possible kmers
$chk[$i]=0;
}
#########################################################################################################################################
print "Unique kmers : \n";$k=1;
for($i=0;$i<$len-$klen+1;$i++){
	for($j=0;$j<$len-$klen+1;$j++){
	if($chk[$i]>0){break;}
	if($i!=$j){
		if($kmer[$i] eq $kmer[$j]){
		$chk[$j]++;
		}
	}
	}
if($chk[$i]==0){
print "Unique kmer $k : $kmer[$i]\n";			#Printing only unique kmers
$unimer[$k-1]=$kmer[$i];
$k++;
}
}
#########################################################################################################################################
for($i=0;$i<$k-1;$i++){
$kno[$i]=$i;
}
allcomb(\@kno,0,scalar(@kno)-1);			#Finding all possible permutations (ORDERS)
$scnum=0;
#print $perm[0];
foreach $x(@perm){
@tmp=split '',$x;
#print "$tmp[0]\n";
$str[$scnum]="";
$str[$scnum].="$unimer[$tmp[0]]";#print "$kmer[$tmp[0]]";
#print "$str[$scnum],$x...\n";
	for($i=1;$i<scalar(@tmp);$i++){
		$strtmp=overlap($str[$scnum],$unimer[$tmp[$i]]);#print "$strtmp\t";	#Overlap function to generate SCS based on order
		$str[$scnum].="$strtmp";
		}
#print "$x : $str[$scnum]\n";
$short=length($str[$scnum]);
if($scnum==0){
$min=$short;
}
if($short<$min){$min=$short;}
$scnum++;
}
print "Shortest Common Superstrings : \n";
for($x=0;$x<$scnum;$x++){
if(length $str[$x]<=$min){$x1++;
print "String $x1 : $str[$x]. Length of string = $min.\n";	#Printing SCS
}
}
